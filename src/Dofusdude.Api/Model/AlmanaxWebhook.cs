// <auto-generated>
/*
 * dofusdude
 *
 * # Open Ankama Developer Community The all-in-one toolbelt for your next Ankama related project.  ## Versions - [Dofus 2](https://docs.dofusdu.de/dofus2/) - [Dofus 3](https://docs.dofusdu.de/dofus3/)   - v1 [latest] (you are here)   ## Client SDKs - [Javascript](https://github.com/dofusdude/dofusdude-js) `npm i dofusdude-js - -save` - [Typescript](https://github.com/dofusdude/dofusdude-ts) `npm i dofusdude-ts - -save` - [Go](https://github.com/dofusdude/dodugo) `go get -u github.com/dofusdude/dodugo` - [Python](https://github.com/dofusdude/dofusdude-py) `pip install dofusdude` - [Java](https://github.com/dofusdude/dofusdude-java) Maven with GitHub packages setup  Everything, including this site, is generated out of the [Docs Repo](https://github.com/dofusdude/api-docs). Consider it the Single Source of Truth. If there is a problem with the SDKs, create an issue there.  Your favorite language is missing? Please let me know!  # Main Features - ü•∑ **Seamless Auto-Update** load data in the background when a new Dofus version is released and serving it within 10 minutes with atomic data source switching. No downtime and no effects for the user, just always up-to-date.  - ‚ö° **Blazingly Fast** all data in-memory, aggressive caching over short time spans, HTTP/2 multiplexing, written in Go, optimized for low latency, hosted on bare metal in üá©üá™.  - üì® **Almanax Discord Integration** Use the endpoints as a dev or the official [Web Client](https://discord.dofusdude.com) as a user.  - ü©∏ **Dofus 3 Beta** from stable to bleeding edge by replacing /dofus3 with /dofus3beta.  - üó£Ô∏è **Multilingual** supporting _en_, _fr_, _es_, _pt_, _de_.  - üß† **Search by Relevance** allowing typos in name and description, handled by language specific text analysis and indexing.  - üïµÔ∏è **Official Sources** generated from actual data from the game.  ... and much more on the Roadmap on my [Discord](https://discord.gg/3EtHskZD8h). 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: stelzo@steado.de
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Dofusdude.Api.Client;

namespace Dofusdude.Api.Model
{
    /// <summary>
    /// AlmanaxWebhook
    /// </summary>
    public partial class AlmanaxWebhook : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="AlmanaxWebhook" /> class.
        /// </summary>
        /// <param name="id">id</param>
        /// <param name="dailySettings">dailySettings</param>
        /// <param name="bonusWhitelist">Only post when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses.</param>
        /// <param name="bonusBlacklist">Skip the day when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses</param>
        /// <param name="subscriptions">Get the available subscriptions with /meta/webhooks/almanax</param>
        /// <param name="isoDate">If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD. (default to false)</param>
        /// <param name="mentions">Almanax bonus ids mapped to array of mentions.</param>
        /// <param name="intervals">- Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.</param>
        /// <param name="weeklyWeekday">When to post the weekly preview at the specified time.</param>
        /// <param name="createdAt">createdAt</param>
        /// <param name="lastFiredAt">lastFiredAt</param>
        /// <param name="updatedAt">updatedAt</param>
        [JsonConstructor]
        public AlmanaxWebhook(Option<Guid?> id = default, Option<AlmanaxWebhookDailySettings?> dailySettings = default, Option<List<string>?> bonusWhitelist = default, Option<List<string>?> bonusBlacklist = default, Option<List<string>?> subscriptions = default, Option<bool?> isoDate = default, Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?> mentions = default, Option<List<AlmanaxWebhook.IntervalsEnum>?> intervals = default, Option<WeeklyWeekdayEnum?> weeklyWeekday = default, Option<DateTime?> createdAt = default, Option<DateTime?> lastFiredAt = default, Option<DateTime?> updatedAt = default)
        {
            IdOption = id;
            DailySettingsOption = dailySettings;
            BonusWhitelistOption = bonusWhitelist;
            BonusBlacklistOption = bonusBlacklist;
            SubscriptionsOption = subscriptions;
            IsoDateOption = isoDate;
            MentionsOption = mentions;
            IntervalsOption = intervals;
            WeeklyWeekdayOption = weeklyWeekday;
            CreatedAtOption = createdAt;
            LastFiredAtOption = lastFiredAt;
            UpdatedAtOption = updatedAt;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Defines Intervals
        /// </summary>
        public enum IntervalsEnum
        {
            /// <summary>
            /// Enum Daily for value: daily
            /// </summary>
            Daily = 1,

            /// <summary>
            /// Enum Weekly for value: weekly
            /// </summary>
            Weekly = 2,

            /// <summary>
            /// Enum Monthly for value: monthly
            /// </summary>
            Monthly = 3
        }

        /// <summary>
        /// Returns a <see cref="IntervalsEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static IntervalsEnum IntervalsEnumFromString(string value)
        {
            if (value.Equals("daily"))
                return IntervalsEnum.Daily;

            if (value.Equals("weekly"))
                return IntervalsEnum.Weekly;

            if (value.Equals("monthly"))
                return IntervalsEnum.Monthly;

            throw new NotImplementedException($"Could not convert value to type IntervalsEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="IntervalsEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static IntervalsEnum? IntervalsEnumFromStringOrDefault(string value)
        {
            if (value.Equals("daily"))
                return IntervalsEnum.Daily;

            if (value.Equals("weekly"))
                return IntervalsEnum.Weekly;

            if (value.Equals("monthly"))
                return IntervalsEnum.Monthly;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="IntervalsEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string IntervalsEnumToJsonValue(IntervalsEnum? value)
        {
            if (value == IntervalsEnum.Daily)
                return "daily";

            if (value == IntervalsEnum.Weekly)
                return "weekly";

            if (value == IntervalsEnum.Monthly)
                return "monthly";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// When to post the weekly preview at the specified time.
        /// </summary>
        /// <value>When to post the weekly preview at the specified time.</value>
        public enum WeeklyWeekdayEnum
        {
            /// <summary>
            /// Enum Sunday for value: sunday
            /// </summary>
            Sunday = 1,

            /// <summary>
            /// Enum Monday for value: monday
            /// </summary>
            Monday = 2,

            /// <summary>
            /// Enum Tuesday for value: tuesday
            /// </summary>
            Tuesday = 3,

            /// <summary>
            /// Enum Wednesday for value: wednesday
            /// </summary>
            Wednesday = 4,

            /// <summary>
            /// Enum Thursday for value: thursday
            /// </summary>
            Thursday = 5,

            /// <summary>
            /// Enum Friday for value: friday
            /// </summary>
            Friday = 6,

            /// <summary>
            /// Enum Saturday for value: saturday
            /// </summary>
            Saturday = 7
        }

        /// <summary>
        /// Returns a <see cref="WeeklyWeekdayEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static WeeklyWeekdayEnum WeeklyWeekdayEnumFromString(string value)
        {
            if (value.Equals("sunday"))
                return WeeklyWeekdayEnum.Sunday;

            if (value.Equals("monday"))
                return WeeklyWeekdayEnum.Monday;

            if (value.Equals("tuesday"))
                return WeeklyWeekdayEnum.Tuesday;

            if (value.Equals("wednesday"))
                return WeeklyWeekdayEnum.Wednesday;

            if (value.Equals("thursday"))
                return WeeklyWeekdayEnum.Thursday;

            if (value.Equals("friday"))
                return WeeklyWeekdayEnum.Friday;

            if (value.Equals("saturday"))
                return WeeklyWeekdayEnum.Saturday;

            throw new NotImplementedException($"Could not convert value to type WeeklyWeekdayEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="WeeklyWeekdayEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static WeeklyWeekdayEnum? WeeklyWeekdayEnumFromStringOrDefault(string value)
        {
            if (value.Equals("sunday"))
                return WeeklyWeekdayEnum.Sunday;

            if (value.Equals("monday"))
                return WeeklyWeekdayEnum.Monday;

            if (value.Equals("tuesday"))
                return WeeklyWeekdayEnum.Tuesday;

            if (value.Equals("wednesday"))
                return WeeklyWeekdayEnum.Wednesday;

            if (value.Equals("thursday"))
                return WeeklyWeekdayEnum.Thursday;

            if (value.Equals("friday"))
                return WeeklyWeekdayEnum.Friday;

            if (value.Equals("saturday"))
                return WeeklyWeekdayEnum.Saturday;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="WeeklyWeekdayEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string? WeeklyWeekdayEnumToJsonValue(WeeklyWeekdayEnum? value)
        {
            if (value == null)
                return null;

            if (value == WeeklyWeekdayEnum.Sunday)
                return "sunday";

            if (value == WeeklyWeekdayEnum.Monday)
                return "monday";

            if (value == WeeklyWeekdayEnum.Tuesday)
                return "tuesday";

            if (value == WeeklyWeekdayEnum.Wednesday)
                return "wednesday";

            if (value == WeeklyWeekdayEnum.Thursday)
                return "thursday";

            if (value == WeeklyWeekdayEnum.Friday)
                return "friday";

            if (value == WeeklyWeekdayEnum.Saturday)
                return "saturday";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of WeeklyWeekday
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<WeeklyWeekdayEnum?> WeeklyWeekdayOption { get; private set; }

        /// <summary>
        /// When to post the weekly preview at the specified time.
        /// </summary>
        /// <value>When to post the weekly preview at the specified time.</value>
        /* <example>sunday</example> */
        [JsonPropertyName("weekly_weekday")]
        public WeeklyWeekdayEnum? WeeklyWeekday { get { return this.WeeklyWeekdayOption; } set { this.WeeklyWeekdayOption = new(value); } }

        /// <summary>
        /// Used to track the state of Id
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Guid?> IdOption { get; private set; }

        /// <summary>
        /// Gets or Sets Id
        /// </summary>
        [JsonPropertyName("id")]
        public Guid? Id { get { return this.IdOption; } set { this.IdOption = new(value); } }

        /// <summary>
        /// Used to track the state of DailySettings
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<AlmanaxWebhookDailySettings?> DailySettingsOption { get; private set; }

        /// <summary>
        /// Gets or Sets DailySettings
        /// </summary>
        [JsonPropertyName("daily_settings")]
        public AlmanaxWebhookDailySettings? DailySettings { get { return this.DailySettingsOption; } set { this.DailySettingsOption = new(value); } }

        /// <summary>
        /// Used to track the state of BonusWhitelist
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> BonusWhitelistOption { get; private set; }

        /// <summary>
        /// Only post when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses.
        /// </summary>
        /// <value>Only post when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses.</value>
        [JsonPropertyName("bonus_whitelist")]
        public List<string>? BonusWhitelist { get { return this.BonusWhitelistOption; } set { this.BonusWhitelistOption = new(value); } }

        /// <summary>
        /// Used to track the state of BonusBlacklist
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> BonusBlacklistOption { get; private set; }

        /// <summary>
        /// Skip the day when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses
        /// </summary>
        /// <value>Skip the day when these bonuses come up. From all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses</value>
        [JsonPropertyName("bonus_blacklist")]
        public List<string>? BonusBlacklist { get { return this.BonusBlacklistOption; } set { this.BonusBlacklistOption = new(value); } }

        /// <summary>
        /// Used to track the state of Subscriptions
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> SubscriptionsOption { get; private set; }

        /// <summary>
        /// Get the available subscriptions with /meta/webhooks/almanax
        /// </summary>
        /// <value>Get the available subscriptions with /meta/webhooks/almanax</value>
        [JsonPropertyName("subscriptions")]
        public List<string>? Subscriptions { get { return this.SubscriptionsOption; } set { this.SubscriptionsOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsoDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsoDateOption { get; private set; }

        /// <summary>
        /// If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD.
        /// </summary>
        /// <value>If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD.</value>
        [JsonPropertyName("iso_date")]
        public bool? IsoDate { get { return this.IsoDateOption; } set { this.IsoDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of Mentions
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?> MentionsOption { get; private set; }

        /// <summary>
        /// Almanax bonus ids mapped to array of mentions.
        /// </summary>
        /// <value>Almanax bonus ids mapped to array of mentions.</value>
        /* <example>{&quot;kolossium-experience&quot;:[{&quot;discord_id&quot;:1234,&quot;is_role&quot;:true,&quot;ping_days_before&quot;:null}]}</example> */
        [JsonPropertyName("mentions")]
        public Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>? Mentions { get { return this.MentionsOption; } set { this.MentionsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Intervals
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<AlmanaxWebhook.IntervalsEnum>?> IntervalsOption { get; private set; }

        /// <summary>
        /// - Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.
        /// </summary>
        /// <value>- Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.</value>
        /* <example>[&quot;daily&quot;]</example> */
        [JsonPropertyName("intervals")]
        public List<AlmanaxWebhook.IntervalsEnum>? Intervals { get { return this.IntervalsOption; } set { this.IntervalsOption = new(value); } }

        /// <summary>
        /// Used to track the state of CreatedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> CreatedAtOption { get; private set; }

        /// <summary>
        /// Gets or Sets CreatedAt
        /// </summary>
        [JsonPropertyName("created_at")]
        public DateTime? CreatedAt { get { return this.CreatedAtOption; } set { this.CreatedAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of LastFiredAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> LastFiredAtOption { get; private set; }

        /// <summary>
        /// Gets or Sets LastFiredAt
        /// </summary>
        [JsonPropertyName("last_fired_at")]
        public DateTime? LastFiredAt { get { return this.LastFiredAtOption; } set { this.LastFiredAtOption = new(value); } }

        /// <summary>
        /// Used to track the state of UpdatedAt
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<DateTime?> UpdatedAtOption { get; private set; }

        /// <summary>
        /// Gets or Sets UpdatedAt
        /// </summary>
        [JsonPropertyName("updated_at")]
        public DateTime? UpdatedAt { get { return this.UpdatedAtOption; } set { this.UpdatedAtOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class AlmanaxWebhook {\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  DailySettings: ").Append(DailySettings).Append("\n");
            sb.Append("  BonusWhitelist: ").Append(BonusWhitelist).Append("\n");
            sb.Append("  BonusBlacklist: ").Append(BonusBlacklist).Append("\n");
            sb.Append("  Subscriptions: ").Append(Subscriptions).Append("\n");
            sb.Append("  IsoDate: ").Append(IsoDate).Append("\n");
            sb.Append("  Mentions: ").Append(Mentions).Append("\n");
            sb.Append("  Intervals: ").Append(Intervals).Append("\n");
            sb.Append("  WeeklyWeekday: ").Append(WeeklyWeekday).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  LastFiredAt: ").Append(LastFiredAt).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="AlmanaxWebhook" />
    /// </summary>
    public class AlmanaxWebhookJsonConverter : JsonConverter<AlmanaxWebhook>
    {
        /// <summary>
        /// The format to use to serialize CreatedAt
        /// </summary>
        public static string CreatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize LastFiredAt
        /// </summary>
        public static string LastFiredAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// The format to use to serialize UpdatedAt
        /// </summary>
        public static string UpdatedAtFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="AlmanaxWebhook" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override AlmanaxWebhook Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Guid?> id = default;
            Option<AlmanaxWebhookDailySettings?> dailySettings = default;
            Option<List<string>?> bonusWhitelist = default;
            Option<List<string>?> bonusBlacklist = default;
            Option<List<string>?> subscriptions = default;
            Option<bool?> isoDate = default;
            Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?> mentions = default;
            Option<List<AlmanaxWebhook.IntervalsEnum>?> intervals = default;
            Option<AlmanaxWebhook.WeeklyWeekdayEnum?> weeklyWeekday = default;
            Option<DateTime?> createdAt = default;
            Option<DateTime?> lastFiredAt = default;
            Option<DateTime?> updatedAt = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "id":
                            id = new Option<Guid?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (Guid?)null : utf8JsonReader.GetGuid());
                            break;
                        case "daily_settings":
                            dailySettings = new Option<AlmanaxWebhookDailySettings?>(JsonSerializer.Deserialize<AlmanaxWebhookDailySettings>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "bonus_whitelist":
                            bonusWhitelist = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "bonus_blacklist":
                            bonusBlacklist = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "subscriptions":
                            subscriptions = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "iso_date":
                            isoDate = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "mentions":
                            mentions = new Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?>(JsonSerializer.Deserialize<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "intervals":
                            intervals = new Option<List<AlmanaxWebhook.IntervalsEnum>?>(JsonSerializer.Deserialize<List<AlmanaxWebhook.IntervalsEnum>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "weekly_weekday":
                            string? weeklyWeekdayRawValue = utf8JsonReader.GetString();
                            if (weeklyWeekdayRawValue != null)
                                weeklyWeekday = new Option<AlmanaxWebhook.WeeklyWeekdayEnum?>(AlmanaxWebhook.WeeklyWeekdayEnumFromStringOrDefault(weeklyWeekdayRawValue));
                            break;
                        case "created_at":
                            createdAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "last_fired_at":
                            lastFiredAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime?>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "updated_at":
                            updatedAt = new Option<DateTime?>(JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class AlmanaxWebhook.");

            if (dailySettings.IsSet && dailySettings.Value == null)
                throw new ArgumentNullException(nameof(dailySettings), "Property is not nullable for class AlmanaxWebhook.");

            if (subscriptions.IsSet && subscriptions.Value == null)
                throw new ArgumentNullException(nameof(subscriptions), "Property is not nullable for class AlmanaxWebhook.");

            if (isoDate.IsSet && isoDate.Value == null)
                throw new ArgumentNullException(nameof(isoDate), "Property is not nullable for class AlmanaxWebhook.");

            if (intervals.IsSet && intervals.Value == null)
                throw new ArgumentNullException(nameof(intervals), "Property is not nullable for class AlmanaxWebhook.");

            if (createdAt.IsSet && createdAt.Value == null)
                throw new ArgumentNullException(nameof(createdAt), "Property is not nullable for class AlmanaxWebhook.");

            if (updatedAt.IsSet && updatedAt.Value == null)
                throw new ArgumentNullException(nameof(updatedAt), "Property is not nullable for class AlmanaxWebhook.");

            return new AlmanaxWebhook(id, dailySettings, bonusWhitelist, bonusBlacklist, subscriptions, isoDate, mentions, intervals, weeklyWeekday, createdAt, lastFiredAt, updatedAt);
        }

        /// <summary>
        /// Serializes a <see cref="AlmanaxWebhook" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="almanaxWebhook"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, AlmanaxWebhook almanaxWebhook, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, almanaxWebhook, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="AlmanaxWebhook" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="almanaxWebhook"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, AlmanaxWebhook almanaxWebhook, JsonSerializerOptions jsonSerializerOptions)
        {
            if (almanaxWebhook.DailySettingsOption.IsSet && almanaxWebhook.DailySettings == null)
                throw new ArgumentNullException(nameof(almanaxWebhook.DailySettings), "Property is required for class AlmanaxWebhook.");

            if (almanaxWebhook.SubscriptionsOption.IsSet && almanaxWebhook.Subscriptions == null)
                throw new ArgumentNullException(nameof(almanaxWebhook.Subscriptions), "Property is required for class AlmanaxWebhook.");

            if (almanaxWebhook.IntervalsOption.IsSet && almanaxWebhook.Intervals == null)
                throw new ArgumentNullException(nameof(almanaxWebhook.Intervals), "Property is required for class AlmanaxWebhook.");

            if (almanaxWebhook.IdOption.IsSet)
                writer.WriteString("id", almanaxWebhook.IdOption.Value!.Value);

            if (almanaxWebhook.DailySettingsOption.IsSet)
            {
                writer.WritePropertyName("daily_settings");
                JsonSerializer.Serialize(writer, almanaxWebhook.DailySettings, jsonSerializerOptions);
            }
            if (almanaxWebhook.BonusWhitelistOption.IsSet)
                if (almanaxWebhook.BonusWhitelistOption.Value != null)
                {
                    writer.WritePropertyName("bonus_whitelist");
                    JsonSerializer.Serialize(writer, almanaxWebhook.BonusWhitelist, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("bonus_whitelist");
            if (almanaxWebhook.BonusBlacklistOption.IsSet)
                if (almanaxWebhook.BonusBlacklistOption.Value != null)
                {
                    writer.WritePropertyName("bonus_blacklist");
                    JsonSerializer.Serialize(writer, almanaxWebhook.BonusBlacklist, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("bonus_blacklist");
            if (almanaxWebhook.SubscriptionsOption.IsSet)
            {
                writer.WritePropertyName("subscriptions");
                JsonSerializer.Serialize(writer, almanaxWebhook.Subscriptions, jsonSerializerOptions);
            }
            if (almanaxWebhook.IsoDateOption.IsSet)
                writer.WriteBoolean("iso_date", almanaxWebhook.IsoDateOption.Value!.Value);

            if (almanaxWebhook.MentionsOption.IsSet)
                if (almanaxWebhook.MentionsOption.Value != null)
                {
                    writer.WritePropertyName("mentions");
                    JsonSerializer.Serialize(writer, almanaxWebhook.Mentions, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("mentions");
            if (almanaxWebhook.IntervalsOption.IsSet)
            {
                writer.WritePropertyName("intervals");
                JsonSerializer.Serialize(writer, almanaxWebhook.Intervals, jsonSerializerOptions);
            }
            var weeklyWeekdayRawValue = AlmanaxWebhook.WeeklyWeekdayEnumToJsonValue(almanaxWebhook.WeeklyWeekdayOption.Value!.Value);
            if (weeklyWeekdayRawValue != null)
                writer.WriteString("weekly_weekday", weeklyWeekdayRawValue);
            else
                writer.WriteNull("weekly_weekday");

            if (almanaxWebhook.CreatedAtOption.IsSet)
                writer.WriteString("created_at", almanaxWebhook.CreatedAtOption.Value!.Value.ToString(CreatedAtFormat));

            if (almanaxWebhook.LastFiredAtOption.IsSet)
                if (almanaxWebhook.LastFiredAtOption.Value != null)
                    writer.WriteString("last_fired_at", almanaxWebhook.LastFiredAtOption.Value!.Value.ToString(LastFiredAtFormat));
                else
                    writer.WriteNull("last_fired_at");

            if (almanaxWebhook.UpdatedAtOption.IsSet)
                writer.WriteString("updated_at", almanaxWebhook.UpdatedAtOption.Value!.Value.ToString(UpdatedAtFormat));
        }
    }
}
