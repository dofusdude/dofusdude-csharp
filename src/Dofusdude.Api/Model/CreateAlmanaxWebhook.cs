// <auto-generated>
/*
 * dofusdude
 *
 * # Open Ankama Developer Community The all-in-one toolbelt for your next Ankama related project.  ## Versions - [Dofus 2](https://docs.dofusdu.de/dofus2/) - [Dofus 3](https://docs.dofusdu.de/dofus3/)   - v1 [latest] (you are here)   ## Client SDKs - [Javascript](https://github.com/dofusdude/dofusdude-js) `npm i dofusdude-js - -save` - [Typescript](https://github.com/dofusdude/dofusdude-ts) `npm i dofusdude-ts - -save` - [Go](https://github.com/dofusdude/dodugo) `go get -u github.com/dofusdude/dodugo` - [Python](https://github.com/dofusdude/dofusdude-py) `pip install dofusdude` - [Java](https://github.com/dofusdude/dofusdude-java) Maven with GitHub packages setup  Everything, including this site, is generated out of the [Docs Repo](https://github.com/dofusdude/api-docs). Consider it the Single Source of Truth. If there is a problem with the SDKs, create an issue there.  Your favorite language is missing? Please let me know!  # Main Features - ü•∑ **Seamless Auto-Update** load data in the background when a new Dofus version is released and serving it within 10 minutes with atomic data source switching. No downtime and no effects for the user, just always up-to-date.  - ‚ö° **Blazingly Fast** all data in-memory, aggressive caching over short time spans, HTTP/2 multiplexing, written in Go, optimized for low latency, hosted on bare metal in üá©üá™.  - üì® **Almanax Discord Integration** Use the endpoints as a dev or the official [Web Client](https://discord.dofusdude.com) as a user.  - ü©∏ **Dofus 3 Beta** from stable to bleeding edge by replacing /dofus3 with /dofus3beta.  - üó£Ô∏è **Multilingual** supporting _en_, _fr_, _es_, _pt_, _de_.  - üß† **Search by Relevance** allowing typos in name and description, handled by language specific text analysis and indexing.  - üïµÔ∏è **Official Sources** generated from actual data from the game.  ... and much more on the Roadmap on my [Discord](https://discord.gg/3EtHskZD8h). 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: stelzo@steado.de
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Dofusdude.Api.Client;

namespace Dofusdude.Api.Model
{
    /// <summary>
    /// CreateAlmanaxWebhook
    /// </summary>
    public partial class CreateAlmanaxWebhook : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="CreateAlmanaxWebhook" /> class.
        /// </summary>
        /// <param name="subscriptions">Get the available subscriptions with /meta/webhooks/almanax</param>
        /// <param name="format">format</param>
        /// <param name="callback">Discord Webhook URL</param>
        /// <param name="intervals">- Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.</param>
        /// <param name="bonusWhitelist">from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses</param>
        /// <param name="bonusBlacklist">from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses</param>
        /// <param name="dailySettings">dailySettings</param>
        /// <param name="isoDate">If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD. (default to false)</param>
        /// <param name="mentions">Almanax bonus ids mapped to array of mentions.</param>
        /// <param name="weeklyWeekday">When to post the weekly preview at the specified time.</param>
        [JsonConstructor]
        public CreateAlmanaxWebhook(List<string> subscriptions, FormatEnum format, string callback, List<CreateAlmanaxWebhook.IntervalsEnum> intervals, Option<List<string>?> bonusWhitelist = default, Option<List<string>?> bonusBlacklist = default, Option<CreateAlmanaxWebhookDailySettings?> dailySettings = default, Option<bool?> isoDate = default, Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?> mentions = default, Option<WeeklyWeekdayEnum?> weeklyWeekday = default)
        {
            Subscriptions = subscriptions;
            Format = format;
            Callback = callback;
            Intervals = intervals;
            BonusWhitelistOption = bonusWhitelist;
            BonusBlacklistOption = bonusBlacklist;
            DailySettingsOption = dailySettings;
            IsoDateOption = isoDate;
            MentionsOption = mentions;
            WeeklyWeekdayOption = weeklyWeekday;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Defines Format
        /// </summary>
        public enum FormatEnum
        {
            /// <summary>
            /// Enum Discord for value: discord
            /// </summary>
            Discord = 1
        }

        /// <summary>
        /// Returns a <see cref="FormatEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static FormatEnum FormatEnumFromString(string value)
        {
            if (value.Equals("discord"))
                return FormatEnum.Discord;

            throw new NotImplementedException($"Could not convert value to type FormatEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="FormatEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static FormatEnum? FormatEnumFromStringOrDefault(string value)
        {
            if (value.Equals("discord"))
                return FormatEnum.Discord;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="FormatEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string FormatEnumToJsonValue(FormatEnum value)
        {
            if (value == FormatEnum.Discord)
                return "discord";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Gets or Sets Format
        /// </summary>
        [JsonPropertyName("format")]
        public FormatEnum Format { get; set; }

        /// <summary>
        /// Defines Intervals
        /// </summary>
        public enum IntervalsEnum
        {
            /// <summary>
            /// Enum Daily for value: daily
            /// </summary>
            Daily = 1,

            /// <summary>
            /// Enum Weekly for value: weekly
            /// </summary>
            Weekly = 2,

            /// <summary>
            /// Enum Monthly for value: monthly
            /// </summary>
            Monthly = 3
        }

        /// <summary>
        /// Returns a <see cref="IntervalsEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static IntervalsEnum IntervalsEnumFromString(string value)
        {
            if (value.Equals("daily"))
                return IntervalsEnum.Daily;

            if (value.Equals("weekly"))
                return IntervalsEnum.Weekly;

            if (value.Equals("monthly"))
                return IntervalsEnum.Monthly;

            throw new NotImplementedException($"Could not convert value to type IntervalsEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="IntervalsEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static IntervalsEnum? IntervalsEnumFromStringOrDefault(string value)
        {
            if (value.Equals("daily"))
                return IntervalsEnum.Daily;

            if (value.Equals("weekly"))
                return IntervalsEnum.Weekly;

            if (value.Equals("monthly"))
                return IntervalsEnum.Monthly;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="IntervalsEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string IntervalsEnumToJsonValue(IntervalsEnum? value)
        {
            if (value == IntervalsEnum.Daily)
                return "daily";

            if (value == IntervalsEnum.Weekly)
                return "weekly";

            if (value == IntervalsEnum.Monthly)
                return "monthly";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// When to post the weekly preview at the specified time.
        /// </summary>
        /// <value>When to post the weekly preview at the specified time.</value>
        public enum WeeklyWeekdayEnum
        {
            /// <summary>
            /// Enum Sunday for value: sunday
            /// </summary>
            Sunday = 1,

            /// <summary>
            /// Enum Monday for value: monday
            /// </summary>
            Monday = 2,

            /// <summary>
            /// Enum Tuesday for value: tuesday
            /// </summary>
            Tuesday = 3,

            /// <summary>
            /// Enum Wednesday for value: wednesday
            /// </summary>
            Wednesday = 4,

            /// <summary>
            /// Enum Thursday for value: thursday
            /// </summary>
            Thursday = 5,

            /// <summary>
            /// Enum Friday for value: friday
            /// </summary>
            Friday = 6,

            /// <summary>
            /// Enum Saturday for value: saturday
            /// </summary>
            Saturday = 7
        }

        /// <summary>
        /// Returns a <see cref="WeeklyWeekdayEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static WeeklyWeekdayEnum WeeklyWeekdayEnumFromString(string value)
        {
            if (value.Equals("sunday"))
                return WeeklyWeekdayEnum.Sunday;

            if (value.Equals("monday"))
                return WeeklyWeekdayEnum.Monday;

            if (value.Equals("tuesday"))
                return WeeklyWeekdayEnum.Tuesday;

            if (value.Equals("wednesday"))
                return WeeklyWeekdayEnum.Wednesday;

            if (value.Equals("thursday"))
                return WeeklyWeekdayEnum.Thursday;

            if (value.Equals("friday"))
                return WeeklyWeekdayEnum.Friday;

            if (value.Equals("saturday"))
                return WeeklyWeekdayEnum.Saturday;

            throw new NotImplementedException($"Could not convert value to type WeeklyWeekdayEnum: '{value}'");
        }

        /// <summary>
        /// Returns a <see cref="WeeklyWeekdayEnum"/>
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static WeeklyWeekdayEnum? WeeklyWeekdayEnumFromStringOrDefault(string value)
        {
            if (value.Equals("sunday"))
                return WeeklyWeekdayEnum.Sunday;

            if (value.Equals("monday"))
                return WeeklyWeekdayEnum.Monday;

            if (value.Equals("tuesday"))
                return WeeklyWeekdayEnum.Tuesday;

            if (value.Equals("wednesday"))
                return WeeklyWeekdayEnum.Wednesday;

            if (value.Equals("thursday"))
                return WeeklyWeekdayEnum.Thursday;

            if (value.Equals("friday"))
                return WeeklyWeekdayEnum.Friday;

            if (value.Equals("saturday"))
                return WeeklyWeekdayEnum.Saturday;

            return null;
        }

        /// <summary>
        /// Converts the <see cref="WeeklyWeekdayEnum"/> to the json value
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <exception cref="NotImplementedException"></exception>
        public static string? WeeklyWeekdayEnumToJsonValue(WeeklyWeekdayEnum? value)
        {
            if (value == null)
                return null;

            if (value == WeeklyWeekdayEnum.Sunday)
                return "sunday";

            if (value == WeeklyWeekdayEnum.Monday)
                return "monday";

            if (value == WeeklyWeekdayEnum.Tuesday)
                return "tuesday";

            if (value == WeeklyWeekdayEnum.Wednesday)
                return "wednesday";

            if (value == WeeklyWeekdayEnum.Thursday)
                return "thursday";

            if (value == WeeklyWeekdayEnum.Friday)
                return "friday";

            if (value == WeeklyWeekdayEnum.Saturday)
                return "saturday";

            throw new NotImplementedException($"Value could not be handled: '{value}'");
        }

        /// <summary>
        /// Used to track the state of WeeklyWeekday
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<WeeklyWeekdayEnum?> WeeklyWeekdayOption { get; private set; }

        /// <summary>
        /// When to post the weekly preview at the specified time.
        /// </summary>
        /// <value>When to post the weekly preview at the specified time.</value>
        /* <example>sunday</example> */
        [JsonPropertyName("weekly_weekday")]
        public WeeklyWeekdayEnum? WeeklyWeekday { get { return this.WeeklyWeekdayOption; } set { this.WeeklyWeekdayOption = new(value); } }

        /// <summary>
        /// Get the available subscriptions with /meta/webhooks/almanax
        /// </summary>
        /// <value>Get the available subscriptions with /meta/webhooks/almanax</value>
        [JsonPropertyName("subscriptions")]
        public List<string> Subscriptions { get; set; }

        /// <summary>
        /// Discord Webhook URL
        /// </summary>
        /// <value>Discord Webhook URL</value>
        /* <example>https://discord.com/api/webhooks/XYZ</example> */
        [JsonPropertyName("callback")]
        public string Callback { get; set; }

        /// <summary>
        /// - Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.
        /// </summary>
        /// <value>- Daily posts each day, filtering with Black/Whitelist and mentions are applied daily. - Weekly posts the next 7 days (excluding the posting day) once per week at the specified time. With only weekly selected, of all mentions, only prior notices will come through daily. The 7 day preview gets filtered by the Black/Whitelist. - Monthly posts a preview of the next month from first to last date. The post will be on the last day of a month (ignoring day of the week) at the specified time. Mentions and filtering works like weekly. The biggest difference between daily and the other two is that daily always posts the current day while monthly and weekly only show future days. You can always combine the intervals by selecting multiple intervals for one hook or create multiple hooks for the same channel with different settings to get every highly specific combination you want.</value>
        /* <example>[&quot;daily&quot;]</example> */
        [JsonPropertyName("intervals")]
        public List<CreateAlmanaxWebhook.IntervalsEnum> Intervals { get; set; }

        /// <summary>
        /// Used to track the state of BonusWhitelist
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> BonusWhitelistOption { get; private set; }

        /// <summary>
        /// from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses
        /// </summary>
        /// <value>from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses</value>
        [JsonPropertyName("bonus_whitelist")]
        public List<string>? BonusWhitelist { get { return this.BonusWhitelistOption; } set { this.BonusWhitelistOption = new(value); } }

        /// <summary>
        /// Used to track the state of BonusBlacklist
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<string>?> BonusBlacklistOption { get; private set; }

        /// <summary>
        /// from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses
        /// </summary>
        /// <value>from all available bonuses (ids) from /dofus3/meta/{language}/almanax/bonuses</value>
        [JsonPropertyName("bonus_blacklist")]
        public List<string>? BonusBlacklist { get { return this.BonusBlacklistOption; } set { this.BonusBlacklistOption = new(value); } }

        /// <summary>
        /// Used to track the state of DailySettings
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<CreateAlmanaxWebhookDailySettings?> DailySettingsOption { get; private set; }

        /// <summary>
        /// Gets or Sets DailySettings
        /// </summary>
        [JsonPropertyName("daily_settings")]
        public CreateAlmanaxWebhookDailySettings? DailySettings { get { return this.DailySettingsOption; } set { this.DailySettingsOption = new(value); } }

        /// <summary>
        /// Used to track the state of IsoDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> IsoDateOption { get; private set; }

        /// <summary>
        /// If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD.
        /// </summary>
        /// <value>If false, it will use common local time formats and weekday translations. If true, the format is YYYY-MM-DD.</value>
        [JsonPropertyName("iso_date")]
        public bool? IsoDate { get { return this.IsoDateOption; } set { this.IsoDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of Mentions
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?> MentionsOption { get; private set; }

        /// <summary>
        /// Almanax bonus ids mapped to array of mentions.
        /// </summary>
        /// <value>Almanax bonus ids mapped to array of mentions.</value>
        /* <example>{&quot;kolossium-experience&quot;:[{&quot;discord_id&quot;:1234,&quot;is_role&quot;:true,&quot;ping_days_before&quot;:null}]}</example> */
        [JsonPropertyName("mentions")]
        public Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>? Mentions { get { return this.MentionsOption; } set { this.MentionsOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class CreateAlmanaxWebhook {\n");
            sb.Append("  Subscriptions: ").Append(Subscriptions).Append("\n");
            sb.Append("  Format: ").Append(Format).Append("\n");
            sb.Append("  Callback: ").Append(Callback).Append("\n");
            sb.Append("  Intervals: ").Append(Intervals).Append("\n");
            sb.Append("  BonusWhitelist: ").Append(BonusWhitelist).Append("\n");
            sb.Append("  BonusBlacklist: ").Append(BonusBlacklist).Append("\n");
            sb.Append("  DailySettings: ").Append(DailySettings).Append("\n");
            sb.Append("  IsoDate: ").Append(IsoDate).Append("\n");
            sb.Append("  Mentions: ").Append(Mentions).Append("\n");
            sb.Append("  WeeklyWeekday: ").Append(WeeklyWeekday).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="CreateAlmanaxWebhook" />
    /// </summary>
    public class CreateAlmanaxWebhookJsonConverter : JsonConverter<CreateAlmanaxWebhook>
    {
        /// <summary>
        /// Deserializes json to <see cref="CreateAlmanaxWebhook" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override CreateAlmanaxWebhook Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<List<string>?> subscriptions = default;
            Option<CreateAlmanaxWebhook.FormatEnum?> format = default;
            Option<string?> callback = default;
            Option<List<CreateAlmanaxWebhook.IntervalsEnum>?> intervals = default;
            Option<List<string>?> bonusWhitelist = default;
            Option<List<string>?> bonusBlacklist = default;
            Option<CreateAlmanaxWebhookDailySettings?> dailySettings = default;
            Option<bool?> isoDate = default;
            Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?> mentions = default;
            Option<CreateAlmanaxWebhook.WeeklyWeekdayEnum?> weeklyWeekday = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "subscriptions":
                            subscriptions = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "format":
                            string? formatRawValue = utf8JsonReader.GetString();
                            if (formatRawValue != null)
                                format = new Option<CreateAlmanaxWebhook.FormatEnum?>(CreateAlmanaxWebhook.FormatEnumFromStringOrDefault(formatRawValue));
                            break;
                        case "callback":
                            callback = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "intervals":
                            intervals = new Option<List<CreateAlmanaxWebhook.IntervalsEnum>?>(JsonSerializer.Deserialize<List<CreateAlmanaxWebhook.IntervalsEnum>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "bonus_whitelist":
                            bonusWhitelist = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "bonus_blacklist":
                            bonusBlacklist = new Option<List<string>?>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "daily_settings":
                            dailySettings = new Option<CreateAlmanaxWebhookDailySettings?>(JsonSerializer.Deserialize<CreateAlmanaxWebhookDailySettings>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "iso_date":
                            isoDate = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "mentions":
                            mentions = new Option<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>?>(JsonSerializer.Deserialize<Dictionary<string, List<CreateAlmanaxWebhookMentionsValueInner>>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "weekly_weekday":
                            string? weeklyWeekdayRawValue = utf8JsonReader.GetString();
                            if (weeklyWeekdayRawValue != null)
                                weeklyWeekday = new Option<CreateAlmanaxWebhook.WeeklyWeekdayEnum?>(CreateAlmanaxWebhook.WeeklyWeekdayEnumFromStringOrDefault(weeklyWeekdayRawValue));
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!subscriptions.IsSet)
                throw new ArgumentException("Property is required for class CreateAlmanaxWebhook.", nameof(subscriptions));

            if (!format.IsSet)
                throw new ArgumentException("Property is required for class CreateAlmanaxWebhook.", nameof(format));

            if (!callback.IsSet)
                throw new ArgumentException("Property is required for class CreateAlmanaxWebhook.", nameof(callback));

            if (!intervals.IsSet)
                throw new ArgumentException("Property is required for class CreateAlmanaxWebhook.", nameof(intervals));

            if (subscriptions.IsSet && subscriptions.Value == null)
                throw new ArgumentNullException(nameof(subscriptions), "Property is not nullable for class CreateAlmanaxWebhook.");

            if (format.IsSet && format.Value == null)
                throw new ArgumentNullException(nameof(format), "Property is not nullable for class CreateAlmanaxWebhook.");

            if (callback.IsSet && callback.Value == null)
                throw new ArgumentNullException(nameof(callback), "Property is not nullable for class CreateAlmanaxWebhook.");

            if (intervals.IsSet && intervals.Value == null)
                throw new ArgumentNullException(nameof(intervals), "Property is not nullable for class CreateAlmanaxWebhook.");

            return new CreateAlmanaxWebhook(subscriptions.Value!, format.Value!.Value!, callback.Value!, intervals.Value!, bonusWhitelist, bonusBlacklist, dailySettings, isoDate, mentions, weeklyWeekday);
        }

        /// <summary>
        /// Serializes a <see cref="CreateAlmanaxWebhook" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="createAlmanaxWebhook"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, CreateAlmanaxWebhook createAlmanaxWebhook, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, createAlmanaxWebhook, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="CreateAlmanaxWebhook" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="createAlmanaxWebhook"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, CreateAlmanaxWebhook createAlmanaxWebhook, JsonSerializerOptions jsonSerializerOptions)
        {
            if (createAlmanaxWebhook.Subscriptions == null)
                throw new ArgumentNullException(nameof(createAlmanaxWebhook.Subscriptions), "Property is required for class CreateAlmanaxWebhook.");

            if (createAlmanaxWebhook.Callback == null)
                throw new ArgumentNullException(nameof(createAlmanaxWebhook.Callback), "Property is required for class CreateAlmanaxWebhook.");

            if (createAlmanaxWebhook.Intervals == null)
                throw new ArgumentNullException(nameof(createAlmanaxWebhook.Intervals), "Property is required for class CreateAlmanaxWebhook.");

            writer.WritePropertyName("subscriptions");
            JsonSerializer.Serialize(writer, createAlmanaxWebhook.Subscriptions, jsonSerializerOptions);
            var formatRawValue = CreateAlmanaxWebhook.FormatEnumToJsonValue(createAlmanaxWebhook.Format);
            writer.WriteString("format", formatRawValue);
            writer.WriteString("callback", createAlmanaxWebhook.Callback);

            writer.WritePropertyName("intervals");
            JsonSerializer.Serialize(writer, createAlmanaxWebhook.Intervals, jsonSerializerOptions);
            if (createAlmanaxWebhook.BonusWhitelistOption.IsSet)
                if (createAlmanaxWebhook.BonusWhitelistOption.Value != null)
                {
                    writer.WritePropertyName("bonus_whitelist");
                    JsonSerializer.Serialize(writer, createAlmanaxWebhook.BonusWhitelist, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("bonus_whitelist");
            if (createAlmanaxWebhook.BonusBlacklistOption.IsSet)
                if (createAlmanaxWebhook.BonusBlacklistOption.Value != null)
                {
                    writer.WritePropertyName("bonus_blacklist");
                    JsonSerializer.Serialize(writer, createAlmanaxWebhook.BonusBlacklist, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("bonus_blacklist");
            if (createAlmanaxWebhook.DailySettingsOption.IsSet)
                if (createAlmanaxWebhook.DailySettingsOption.Value != null)
                {
                    writer.WritePropertyName("daily_settings");
                    JsonSerializer.Serialize(writer, createAlmanaxWebhook.DailySettings, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("daily_settings");
            if (createAlmanaxWebhook.IsoDateOption.IsSet)
                if (createAlmanaxWebhook.IsoDateOption.Value != null)
                    writer.WriteBoolean("iso_date", createAlmanaxWebhook.IsoDateOption.Value!.Value);
                else
                    writer.WriteNull("iso_date");

            if (createAlmanaxWebhook.MentionsOption.IsSet)
                if (createAlmanaxWebhook.MentionsOption.Value != null)
                {
                    writer.WritePropertyName("mentions");
                    JsonSerializer.Serialize(writer, createAlmanaxWebhook.Mentions, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("mentions");
            var weeklyWeekdayRawValue = CreateAlmanaxWebhook.WeeklyWeekdayEnumToJsonValue(createAlmanaxWebhook.WeeklyWeekdayOption.Value!.Value);
            if (weeklyWeekdayRawValue != null)
                writer.WriteString("weekly_weekday", weeklyWeekdayRawValue);
            else
                writer.WriteNull("weekly_weekday");
        }
    }
}
